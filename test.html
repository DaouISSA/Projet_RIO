<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Parking Issa - Syst√®me de Gestion</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1000px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .reset-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .message {
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            min-height: 40px;
            display: flex;
            align-items: center;
            font-weight: 500;
            color: #333;
        }

        .message.success {
            border-left-color: #4caf50;
            background: #e8f5e9;
        }

        .message.error {
            border-left-color: #f44336;
            background: #ffebee;
            color: #c62828;
        }

        .parking-container {
            display: flex;
            gap: 30px;
            margin-top: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .parking-grid {
            background: #f9f9f9;
            border: 2px solid #ddd;
            padding: 20px;
            border-radius: 10px;
            display: inline-block;
        }

        .parking-label {
            text-align: center;
            font-weight: bold;
            margin-bottom: 15px;
            color: #555;
            font-size: 14px;
        }

        .row {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 900px;
        }

        .spot {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #999;
            border-radius: 4px;
            font-weight: bold;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            background: white;
        }

        .spot.free {
            background: #4caf50;
            color: white;
            border-color: #388e3c;
        }

        .spot.occupied {
            background: #f44336;
            color: white;
            border-color: #d32f2f;
        }

        .spot.assigned {
            background: #2196f3;
            color: white;
            border-color: #1976d2;
            box-shadow: 0 0 15px #2196f3;
            animation: pulse 1s infinite;
        }

        .spot:hover {
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 15px #2196f3; }
            50% { box-shadow: 0 0 25px #2196f3, 0 0 40px #2196f3; }
        }

        .canvas-container {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        #parkingMap {
            border: 3px solid #333;
            background: #fff;
            max-width: 100%;
            height: auto;
        }

        .stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .stat {
            padding: 15px 25px;
            background: white;
            border-radius: 8px;
            border: 2px solid #ddd;
            text-align: center;
            min-width: 150px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
            text-transform: uppercase;
        }

        .itinerary {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            display: none;
        }

        .itinerary.show {
            display: block;
        }

        .itinerary h3 {
            color: #1976d2;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .itinerary ol {
            margin-left: 20px;
            color: #333;
            font-size: 14px;
        }

        .itinerary li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üÖøÔ∏è Parking Issa</h1>
        
        <div class="controls">
            <button onclick="reserverPlace()">‚úì R√©server une place</button>
            <button class="reset-btn" onclick="resetParking()">‚Üª R√©initialiser</button>
        </div>

        <div id="message" class="message" style="display:none;"></div>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="totalSpots">-</div>
                <div class="stat-label">Places Totales</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="freeSpots">-</div>
                <div class="stat-label">Places Libres</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="occupiedSpots">-</div>
                <div class="stat-label">Places Occup√©es</div>
            </div>
        </div>

        <div class="parking-container">
            <div class="parking-grid">
                <div class="parking-label">Rang√©e A (Haut)</div>
                <div class="row" id="rowA"></div>
            </div>
            <div class="parking-grid">
                <div class="parking-label">Rang√©e B (Bas)</div>
                <div class="row" id="rowB"></div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="parkingMap" width="800" height="400"></canvas>
        </div>

        <div id="itinerary" class="itinerary">
            <h3>üìç Itin√©raire vers votre place</h3>
            <ol id="itineraryList"></ol>
        </div>
    </div>

    <script>
        // D√©tecter automatiquement l'IP et le port du serveur
        const API_URL = `http://${window.location.hostname}:${window.location.port || 8000}`;
        const WS_URL = `ws://${window.location.hostname}:${window.location.port || 8000}/ws`;
        const canvas = document.getElementById('parkingMap');
        const ctx = canvas.getContext('2d');
        
        let parkingData = {};
        let assignedSpot = null;
        let ws = null;

        // Connecter au WebSocket - SUPPRIM√â
        // Les mises √† jour sont maintenant faites par polling (updateStatus toutes les 2s)

        // Initialiser le parking
        async function initParking() {
            await updateStatus();
            renderGrid();
            drawParkingMap();
        }

        // R√©cup√©rer l'√©tat du parking
        async function updateStatus() {
            try {
                const res = await fetch(`${API_URL}/parking/status`);
                const data = await res.json();
                parkingData = {};
                data.forEach(spot => {
                    parkingData[spot.id] = spot;
                });
                updateStats();
            } catch (err) {
                console.error('Erreur:', err);
                showMessage('Erreur de connexion au serveur', 'error');
            }
        }

        // Mettre √† jour les statistiques
        function updateStats() {
            const total = Object.keys(parkingData).length;
            const free = Object.values(parkingData).filter(s => s.status === 'free').length;
            const occupied = total - free;
            
            document.getElementById('totalSpots').textContent = total;
            document.getElementById('freeSpots').textContent = free;
            document.getElementById('occupiedSpots').textContent = occupied;
        }

        // Afficher la grille de places
        function renderGrid() {
            const rowA = document.getElementById('rowA');
            const rowB = document.getElementById('rowB');
            
            rowA.innerHTML = '';
            rowB.innerHTML = '';

            // Rang√©e A (places A1 √† A5)
            for (let i = 1; i <= 5; i++) {
                const id = `A${i}`;
                const spot = parkingData[id];
                if (spot) {
                    const div = createSpotElement(id, spot);
                    rowA.appendChild(div);
                }
            }

            // Rang√©e B (places B1 √† B5)
            for (let i = 1; i <= 5; i++) {
                const id = `B${i}`;
                const spot = parkingData[id];
                if (spot) {
                    const div = createSpotElement(id, spot);
                    rowB.appendChild(div);
                }
            }
        }

        // Cr√©er un √©l√©ment place
        function createSpotElement(id, spot) {
            const div = document.createElement('div');
            div.className = `spot ${spot.status}`;
            if (assignedSpot === id) div.classList.add('assigned');
            div.textContent = id;
            return div;
        }

        // R√©server une place
        async function reserverPlace() {
            try {
                const res = await fetch(`${API_URL}/booking/request`, { method: 'POST' });
                const data = await res.json();

                if (data.status === "success") {
                    assignedSpot = data.assigned_spot;
                    await updateStatus();
                    renderGrid();
                    
                    const msg = `‚úì Place ${data.assigned_spot} r√©serv√©e avec succ√®s`;
                    showMessage(msg, 'success');
                    
                    // Passer les waypoints √† la fonction
                    tracerItineraire(data.assigned_coordinates, data.itinerary_steps, data.waypoints);
                    
                    // Actualiser apr√®s 500ms
                    setTimeout(updateStatus, 500);
                } else {
                    showMessage('‚ùå ' + data.message, 'error');
                }
            } catch (err) {
                console.error('Erreur:', err);
                showMessage('Erreur lors de la r√©servation', 'error');
            }
        }

        // R√©initialiser le parking
        async function resetParking() {
            try {
                const res = await fetch(`${API_URL}/parking/reset`, { method: 'POST' });
                const data = await res.json();
                
                assignedSpot = null;
                await updateStatus();
                renderGrid();
                drawParkingMap();
                document.getElementById('itinerary').classList.remove('show');
                showMessage('‚úì Parking r√©initialis√©', 'success');
            } catch (err) {
                console.error('Erreur:', err);
                showMessage('Erreur lors de la r√©initialisation', 'error');
            }
        }

        // Afficher un message
        function showMessage(text, type = 'info') {
            const msgDiv = document.getElementById('message');
            msgDiv.textContent = text;
            msgDiv.className = `message ${type}`;
            msgDiv.style.display = 'flex';
            
            if (type !== 'error') {
                setTimeout(() => msgDiv.style.display = 'none', 5000);
            }
        }

        // Tracer l'itin√©raire sur le canvas
        function tracerItineraire(dest, steps, waypoints = null) {
            drawParkingMap();
            
            // Si pas de waypoints, les cr√©er
           /* if (!waypoints) {
                waypoints = [
                    { x: 100, y: 100 }, // Entr√©e
                    { x: dest.x, y: 100 },
                    { x: dest.x, y: 0 },
                    { x: dest.x, y: dest.y }
                ];
            }*/

            // Convertir les waypoints en coordonn√©es √©cran
            const padding = 100;
            const workWidth = canvas.width - 2 * padding;
            const workHeight = canvas.height - 2 * padding - 50;

            const screenWaypoints = waypoints.map(wp => ({
                x: padding + (wp.x / 100) * workWidth,
                y: padding + 50 + (wp.y / 100) * workHeight
            }));

            // Tracer le chemin avec tous les points interm√©diaires
            ctx.beginPath();
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 5;
            ctx.setLineDash([10, 5]);
            
            // Commencer depuis le premier waypoint
            ctx.moveTo(screenWaypoints[0].x, screenWaypoints[0].y);
            
            // Tracer vers chaque waypoint
            for (let i = 1; i < screenWaypoints.length; i++) {
                ctx.lineTo(screenWaypoints[i].x, screenWaypoints[i].y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Dessiner les points interm√©diaires
            screenWaypoints.forEach((point, index) => {
                ctx.fillStyle = index === 0 ? '#2196f3' : (index === screenWaypoints.length - 1 ? '#4caf50' : '#ff9800');
                ctx.beginPath();
                ctx.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                ctx.fill();
                
                // Num√©ro du point
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(index + 1, point.x, point.y);
            });

            // Ajouter des fl√®ches de direction
            for (let i = 0; i < screenWaypoints.length - 1; i++) {
                const fromPoint = screenWaypoints[i];
                const toPoint = screenWaypoints[i + 1];
                
                // Calculer l'angle
                const angle = Math.atan2(toPoint.y - fromPoint.y, toPoint.x - fromPoint.x);
                const midX = (fromPoint.x + toPoint.x) / 2;
                const midY = (fromPoint.y + toPoint.y) / 2;
                
                // Dessiner la fl√®che
                const arrowSize = 15;
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.moveTo(midX, midY);
                ctx.lineTo(midX - arrowSize * Math.cos(angle - Math.PI / 6), midY - arrowSize * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(midX - arrowSize * Math.cos(angle + Math.PI / 6), midY - arrowSize * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
            }

            // Afficher l'itin√©raire d√©taill√©
            const itineraryDiv = document.getElementById('itinerary');
            const itineraryList = document.getElementById('itineraryList');
            itineraryList.innerHTML = steps.map(step => `<li>${step}</li>`).join('');
            itineraryDiv.classList.add('show');
        }

        // Dessiner le plan du parking
        function drawParkingMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Fond
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Bordure
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // All√©e principale (ligne centrale)
            const padding = 100;
            const workHeight = canvas.height - 2 * padding - 50;
            const allee_y = padding + 50 + (45 / 100) * workHeight;
            
            // Entr√©e (tout en bas au centre)
            const entryX = canvas.width / 2 + 295;
            const entryY = canvas.height - 30;
            ctx.fillStyle = '#2196f3';
            ctx.fillRect(entryX - 40, entryY - 20, 80, 40);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ENTR√âE', entryX, entryY);
            
            ctx.strokeStyle = '#ffeb3b';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(padding, allee_y);
            ctx.lineTo(canvas.width - padding, allee_y);
            ctx.stroke();
            ctx.setLineDash([]);

            // Grille de places avec un vrai syst√®me de coordonn√©es
            const workWidth = canvas.width - 2 * padding;

            // Taille des places
            const spotSize = 40;

            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            Object.entries(parkingData).forEach(([id, spot]) => {
                // Convertir les coordonn√©es DB en coordonn√©es √©cran
                const screenX = padding + (spot.pos_x / 100) * workWidth;
                const screenY = padding + 50 + (spot.pos_y / 100) * workHeight;

                // Couleur selon le statut
                if (spot.status === 'occupied') {
                    ctx.fillStyle = '#f44336';
                } else if (assignedSpot === id) {
                    ctx.fillStyle = '#4caf50';
                } else {
                    ctx.fillStyle = '#c8e6c9';
                }

                ctx.fillRect(screenX - spotSize / 2, screenY - spotSize / 2, spotSize, spotSize);
                
                // Bordure
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX - spotSize / 2, screenY - spotSize / 2, spotSize, spotSize);

                // Texte
                ctx.fillStyle = '#333';
                ctx.fillText(id, screenX, screenY);
            });
        }

        // Initialiser au chargement
        initParking();
    </script>
</body>
</html>